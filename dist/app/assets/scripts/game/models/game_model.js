// Generated by CoffeeScript 1.7.1
(function() {
  this.TicTacToe.module("GameApp", function(GameApp, App, Backbone, Marionette, $, _) {
    return GameApp.GameModel = (function() {
      function GameModel() {
        this.board = this.buildBoard();
      }

      GameModel.prototype.reset = function() {
        return this.board = this.buildBoard();
      };

      GameModel.prototype.changeBoard = function(parentLocation, location, player) {
        var parsedLocation;
        parsedLocation = this.parseLocation(parentLocation.className, location.className);
        if (parsedLocation.length > 2) {
          this.board.table[parsedLocation[0]][parsedLocation[1]].table[parsedLocation[2]][parsedLocation[3]].val = player;
          return this.checkBoard(player, parsedLocation.slice(0, 2));
        } else {
          this.board.table[parsedLocation[0]][parsedLocation[1]].val = player;
          return this.checkBoard(player);
        }
      };

      GameModel.prototype.checkLocation = function(parentLocation, location) {
        var parsedLocation;
        parsedLocation = this.parseLocation(parentLocation.className, location.className);
        if (parsedLocation.length > 2) {
          if (this.board.table[parsedLocation[0]][parsedLocation[1]].table[parsedLocation[2]][parsedLocation[3]].val === 0) {
            return true;
          }
          return false;
        } else {
          if (this.board.table[parsedLocation[0]][parsedLocation[1]].val === 0) {
            return true;
          }
          return false;
        }
      };

      GameModel.prototype.checkBoard = function(player, location) {
        if (location != null) {
          if ((this.checkRows(player, location) || this.checkColumns(player, location) || this.checkCross(player, location)) && this.board.table[location[0]][location[1]].val === 0) {
            this.board.table[location[0]][location[1]].val = player;
            return true;
          }
          return false;
        } else {
          if (this.checkRows(player) || this.checkColumns(player) || this.checkCross(player)) {
            this.board.val = player;
            return true;
          }
          return false;
        }
      };

      GameModel.prototype.isFull = function(location, subBoard) {
        var cell, currentBoard, parsedLocation, row, _i, _j, _len, _len1;
        currentBoard = this.board.table;
        if (subBoard == null) {
          if (location != null) {
            parsedLocation = this.parseLocation(location);
            currentBoard = this.board.table[parsedLocation[0]][parsedLocation[1]].table;
          }
        } else {
          currentBoard = subBoard;
        }
        for (_i = 0, _len = currentBoard.length; _i < _len; _i++) {
          row = currentBoard[_i];
          for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
            cell = row[_j];
            if (((location != null) || !this.isFull(0, cell.table)) && cell.val === 0) {
              return false;
            }
          }
        }
        return true;
      };

      GameModel.prototype.parseBackLocation = function(x, y, parentLocation) {
        var parsedBackLocation;
        parsedBackLocation = Array();
        switch (x) {
          case 0:
            parsedBackLocation.push("up");
            break;
          case 1:
            parsedBackLocation.push("center");
            if (y === 1) {
              parsedBackLocation.push("centers");
            }
            break;
          case 2:
            parsedBackLocation.push("down");
        }
        switch (y) {
          case 0:
            parsedBackLocation.push("left");
            break;
          case 1:
            if (x !== 1) {
              parsedBackLocation.push("center");
            }
            break;
          case 2:
            parsedBackLocation.push("right");
        }
        if (parentLocation != null) {
          parsedBackLocation.push("in");
          return $("." + parentLocation.className.split(" ").join(".") + " ." + parsedBackLocation.join("."))[0];
        } else {
          parsedBackLocation.push("out");
          return $("." + parsedBackLocation.join("."))[0];
        }
      };

      GameModel.prototype.checkRows = function(player, location) {
        var currentBoard, i, _i, _ref, _ref1;
        if (location != null) {
          currentBoard = this.board.table[location[0]][location[1]].table;
        } else {
          currentBoard = this.board.table;
        }
        for (i = _i = 0; _i <= 2; i = ++_i) {
          if (((player === (_ref1 = currentBoard[i][0].val) && _ref1 === (_ref = currentBoard[i][1].val)) && _ref === currentBoard[i][2].val)) {
            return true;
          }
        }
        return false;
      };

      GameModel.prototype.checkColumns = function(player, location) {
        var currentBoard, i, _i, _ref, _ref1;
        if (location != null) {
          currentBoard = this.board.table[location[0]][location[1]].table;
        } else {
          currentBoard = this.board.table;
        }
        for (i = _i = 0; _i <= 2; i = ++_i) {
          if (((player === (_ref1 = currentBoard[0][i].val) && _ref1 === (_ref = currentBoard[1][i].val)) && _ref === currentBoard[2][i].val)) {
            return true;
          }
        }
        return false;
      };

      GameModel.prototype.checkCross = function(player, location) {
        var currentBoard, _ref, _ref1, _ref2, _ref3;
        if (location != null) {
          currentBoard = this.board.table[location[0]][location[1]].table;
        } else {
          currentBoard = this.board.table;
        }
        if (((player === (_ref1 = currentBoard[0][0].val) && _ref1 === (_ref = currentBoard[1][1].val)) && _ref === currentBoard[2][2].val)) {
          return true;
        }
        if (((player === (_ref3 = currentBoard[2][0].val) && _ref3 === (_ref2 = currentBoard[1][1].val)) && _ref2 === currentBoard[0][2].val)) {
          return true;
        }
        return false;
      };

      GameModel.prototype.getMoves = function(validLocation) {
        var i, j, k, l, moves, subBoard, _i, _j, _k, _l, _m, _n;
        moves = [];
        if (validLocation !== true) {
          validLocation = this.parseLocation(validLocation);
          subBoard = this.board.table[validLocation[0]][validLocation[1]].table;
          for (i = _i = 0; _i <= 2; i = ++_i) {
            for (j = _j = 0; _j <= 2; j = ++_j) {
              if (subBoard[i][j].val === 0) {
                moves.push([validLocation[0], validLocation[1], i, j]);
              }
            }
          }
        } else {
          for (i = _k = 0; _k <= 2; i = ++_k) {
            for (j = _l = 0; _l <= 2; j = ++_l) {
              for (k = _m = 0; _m <= 2; k = ++_m) {
                for (l = _n = 0; _n <= 2; l = ++_n) {
                  if (this.board.table[i][j].table[k][l].val === 0) {
                    moves.push([i, j, k, l]);
                  }
                }
              }
            }
          }
        }
        return moves;
      };

      GameModel.prototype.getWinningLines = function() {
        var board, end, i, lines, start, winner, _i, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
        winner = this.board.val;
        board = this.board.table;
        lines = [];
        for (i = _i = 0, _ref = board.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (((board[i][0].val === (_ref2 = board[i][1].val) && _ref2 === (_ref1 = board[i][2].val)) && _ref1 === winner)) {
            start = $(this.parseBackLocation(i, 0));
            end = $(this.parseBackLocation(i, 2));
            start = {
              x: start.position().left + 10,
              y: start.position().top + start.width() / 2
            };
            end = {
              x: end.position().left + end.width() - 10,
              y: end.position().top + end.width() / 2
            };
          } else if (((board[0][i].val === (_ref4 = board[1][i].val) && _ref4 === (_ref3 = board[2][i].val)) && _ref3 === winner)) {
            start = $(this.parseBackLocation(0, i));
            end = $(this.parseBackLocation(2, i));
            start = {
              x: start.position().left + start.width() / 2,
              y: start.position().top + 10
            };
            end = {
              x: end.position().left + end.width() / 2,
              y: end.position().top + end.width() - 10
            };
          } else {
            continue;
          }
          lines.push({
            start: start,
            end: end
          });
        }
        if (((board[0][0].val === (_ref6 = board[1][1].val) && _ref6 === (_ref5 = board[2][2].val)) && _ref5 === winner)) {
          start = $(this.parseBackLocation(0, 0));
          end = $(this.parseBackLocation(2, 2));
          start = {
            x: start.position().left + 10,
            y: start.position().top + 10
          };
          end = {
            x: end.position().left + end.width() - 10,
            y: end.position().top + end.width() - 10
          };
          lines.push({
            start: start,
            end: end
          });
        }
        if (((board[0][2].val === (_ref8 = board[1][1].val) && _ref8 === (_ref7 = board[2][0].val)) && _ref7 === winner)) {
          start = $(this.parseBackLocation(0, 2));
          end = $(this.parseBackLocation(2, 0));
          start = {
            x: start.position().left + start.width(),
            y: start.position().top
          };
          end = {
            x: end.position().left,
            y: end.position().top + end.width()
          };
          lines.push({
            start: start,
            end: end
          });
        }
        return lines;
      };

      GameModel.prototype.parseLocation = function(parentLocation, location) {
        var i, loc, locations, parentLocations, parsedLocation, temp, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        parsedLocation = Array();
        parentLocations = parentLocation.split(" ");
        for (i = _i = 0, _ref = parentLocations.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if ((_ref1 = parentLocations[i]) === "in" || _ref1 === "out" || _ref1 === "active") {
            parentLocations.splice(i, 1);
          }
        }
        if ((_ref2 = parentLocations[1]) === "up" || _ref2 === "down") {
          temp = parentLocations[0];
          parentLocations[0] = parentLocations[1];
          parentLocations[1] = temp;
        }
        for (_j = 0, _len = parentLocations.length; _j < _len; _j++) {
          loc = parentLocations[_j];
          switch (loc) {
            case "up":
            case "left":
              parsedLocation.push(0);
              break;
            case "center":
            case "centers":
              parsedLocation.push(1);
              break;
            case "down":
            case "right":
              parsedLocation.push(2);
          }
        }
        if (location != null) {
          locations = location.split(" ");
          for (i = _k = 0, _ref3 = locations.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
            if ((_ref4 = locations[i]) === "in" || _ref4 === "out" || _ref4 === "active") {
              locations.splice(i, 1);
            }
          }
          if ((_ref5 = locations[1]) === "up" || _ref5 === "down") {
            temp = locations[0];
            locations[0] = locations[1];
            locations[1] = temp;
          }
          for (_l = 0, _len1 = locations.length; _l < _len1; _l++) {
            loc = locations[_l];
            switch (loc) {
              case "up":
              case "left":
                parsedLocation.push(0);
                break;
              case "center":
              case "centers":
                parsedLocation.push(1);
                break;
              case "down":
              case "right":
                parsedLocation.push(2);
            }
          }
        }
        return parsedLocation;
      };

      GameModel.prototype.buildBoard = function() {
        var column, newBoard, subBoard, subColumn, val, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
        newBoard = {
          table: new Array(3),
          val: 0
        };
        for (column = _i = 0, _ref = newBoard.table.length; 0 <= _ref ? _i < _ref : _i > _ref; column = 0 <= _ref ? ++_i : --_i) {
          newBoard.table[column] = new Array(3);
          for (subBoard = _j = 0, _ref1 = newBoard.table[column].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; subBoard = 0 <= _ref1 ? ++_j : --_j) {
            newBoard.table[column][subBoard] = {
              table: new Array(3),
              val: 0
            };
            for (subColumn = _k = 0, _ref2 = newBoard.table[column][subBoard].table.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; subColumn = 0 <= _ref2 ? ++_k : --_k) {
              newBoard.table[column][subBoard].table[subColumn] = new Array(3);
              for (val = _l = 0, _ref3 = newBoard.table[column][subBoard].table[subColumn].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; val = 0 <= _ref3 ? ++_l : --_l) {
                newBoard.table[column][subBoard].table[subColumn][val] = {
                  val: 0
                };
              }
            }
          }
        }
        return newBoard;
      };

      GameModel.prototype.copyBoard = function(board) {
        var column, newBoard, subBoard, subColumn, val, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
        newBoard = {
          table: new Array(3),
          val: 0
        };
        for (column = _i = 0, _ref = newBoard.table.length; 0 <= _ref ? _i < _ref : _i > _ref; column = 0 <= _ref ? ++_i : --_i) {
          newBoard.table[column] = new Array(3);
          for (subBoard = _j = 0, _ref1 = newBoard.table[column].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; subBoard = 0 <= _ref1 ? ++_j : --_j) {
            newBoard.table[column][subBoard] = {
              table: new Array(3),
              val: 0
            };
            for (subColumn = _k = 0, _ref2 = newBoard.table[column][subBoard].table.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; subColumn = 0 <= _ref2 ? ++_k : --_k) {
              newBoard.table[column][subBoard].table[subColumn] = new Array(3);
              for (val = _l = 0, _ref3 = newBoard.table[column][subBoard].table[subColumn].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; val = 0 <= _ref3 ? ++_l : --_l) {
                newBoard.table[column][subBoard].table[subColumn][val] = {
                  val: board.table[column][subBoard].table[subColumn][val].val
                };
              }
            }
          }
        }
        return newBoard;
      };

      return GameModel;

    })();
  });

}).call(this);
