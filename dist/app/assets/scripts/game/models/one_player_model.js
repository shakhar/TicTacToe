// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.TicTacToe.module("GameApp", function(GameApp, App, Backbone, Marionette, $, _) {
    return GameApp.OnePlayerModel = (function(_super) {
      __extends(OnePlayerModel, _super);

      function OnePlayerModel() {
        OnePlayerModel.__super__.constructor.apply(this, arguments);
        this.validLocation = true;
        this.difficulty = "easy";
        this.level = 1;
      }

      OnePlayerModel.prototype.reset = function() {
        OnePlayerModel.__super__.reset.apply(this, arguments);
        return this.validLocation = true;
      };

      OnePlayerModel.prototype.alphaBeta = function(validLocation) {
        this.model.movesLeft = 1000000;
        if (validLocation === true) {
          this.validLocation = true;
        } else {
          this.validLocation = this.parseLocation(validLocation);
        }
        return this.maxValue(this, -100000, 100000, true, 1);
      };

      OnePlayerModel.prototype.maxValue = function(state, alpha, beta, isFirst, level) {
        var bestMove, min, move, moves, score, v, _i, _len;
        isFirst = isFirst || false;
        if (state.isTerminal(level)) {
          score = state.boardScore();
          if (Math.abs(score === 10000)) {
            score *= 8 - level;
          }
          return score;
        }
        v = -100000;
        moves = state.getMoves();
        bestMove = moves[0];
        for (_i = 0, _len = moves.length; _i < _len; _i++) {
          move = moves[_i];
          min = this.minValue(state.getNext(move, "max"), alpha, beta, false, level + 1);
          if (min > v) {
            v = min;
            bestMove = move;
          }
          if (v >= beta) {
            if (isFirst) {
              return move;
            }
            return v;
          }
          if (v > alpha) {
            alpha = v;
          }
        }
        if (isFirst) {
          return bestMove;
        } else {
          return v;
        }
      };

      OnePlayerModel.prototype.minValue = function(state, alpha, beta, isFirst, level) {
        var bestMove, max, move, moves, score, v, _i, _len;
        isFirst = isFirst || false;
        if (state.isTerminal(level)) {
          score = state.boardScore();
          if (Math.abs(score === 10000)) {
            score *= 8 - level;
          }
          return score;
        }
        v = 100000;
        moves = state.getMoves();
        bestMove = moves[0];
        for (_i = 0, _len = moves.length; _i < _len; _i++) {
          move = moves[_i];
          max = this.maxValue(state.getNext(move, "min"), alpha, beta, false, level + 1);
          if (max < v) {
            v = max;
            bestMove = moves;
          }
          if (v <= alpha) {
            if (isFirst) {
              return move;
            }
            return v;
          }
          if (v < beta) {
            beta = v;
          }
        }
        if (isFirst) {
          return bestMove;
        } else {
          return v;
        }
      };

      OnePlayerModel.prototype.subBoardScore = function(location) {
        var nextBoard;
        nextBoard = this.board.table[location[0]][location[1]];
        if (this.isFull(0, nextBoard.table)) {
          return -1;
        }
        if (nextBoard.val !== 0) {
          return 1;
        }
        return 0;
      };

      OnePlayerModel.prototype.getMoves = function() {
        var i, j, k, l, moves, moves1, moves2, moves3, subScore, _i, _j, _k, _l;
        moves = new Array();
        moves1 = new Array();
        moves2 = new Array();
        moves3 = new Array();
        for (i = _i = 0; _i < 3; i = ++_i) {
          for (j = _j = 0; _j < 3; j = ++_j) {
            if (this.validLocation === true) {
              for (k = _k = 0; _k < 3; k = ++_k) {
                for (l = _l = 0; _l < 3; l = ++_l) {
                  if (this.board.table[i][j].table[k][l].val === 0) {
                    subScore = this.subBoardScore([k, l]);
                    if (this.boardGoingToEnd([k, l])) {
                      moves.push([i, j, k, l]);
                    }
                    if (subScore === 1) {
                      moves1.push([i, j, k, l]);
                    }
                    if (subScore === 0) {
                      moves2.push([i, j, k, l]);
                    }
                    if (subScore === -1) {
                      moves3.push([i, j, k, l]);
                    }
                  }
                }
              }
            } else {
              if (this.board.table[this.validLocation[0]][this.validLocation[1]].table[i][j].val === 0) {
                subScore = this.subBoardScore([i, j]);
                if (this.boardGoingToEnd([i, j])) {
                  moves.push([this.validLocation[0], this.validLocation[1], i, j]);
                }
                if (subScore === 1) {
                  moves1.push([this.validLocation[0], this.validLocation[1], i, j]);
                }
                if (subScore === 0) {
                  moves2.push([this.validLocation[0], this.validLocation[1], i, j]);
                }
                if (subScore === -1) {
                  moves3.push([this.validLocation[0], this.validLocation[1], i, j]);
                }
              }
            }
          }
        }
        if (moves1.length > 0) {
          this.model.movesLeft -= moves1.length;
          return moves.concat(moves1);
        } else if (moves2.length > 0) {
          this.model.movesLeft -= moves2.length;
          return moves.concat(moves2);
        } else {
          this.model.movesLeft -= moves3.length;
          return moves.concat(moves3);
        }
      };

      OnePlayerModel.prototype.isTerminal = function(level) {
        var i, j, noSpaces, _i, _j;
        noSpaces = true;
        for (i = _i = 0; _i < 3; i = ++_i) {
          for (j = _j = 0; _j < 3; j = ++_j) {
            if (this.board.table[i][j].val === 0) {
              noSpaces = false;
            }
          }
        }
        return noSpaces || this.isGameOver() || level > this.level || this.model.movesLeft < 0;
      };

      OnePlayerModel.prototype.isGameOver = function() {
        return Math.abs(this.boardScore() === 10000);
      };

      OnePlayerModel.prototype.getNext = function(move, player) {
        var nextState;
        if (player === "max") {
          player = 1;
        } else {
          player = -1;
        }
        nextState = new GameApp.OnePlayerModel();
        nextState.board = this.copyBoard(this.board);
        nextState.board.table[move[0]][move[1]].table[move[2]][move[3]].val = player;
        nextState.validLocation = [move[2], move[3]];
        return nextState;
      };

      OnePlayerModel.prototype.boardGoingToEnd = function(validLocation) {
        var i, subBoard, _i;
        subBoard = this.board.table[validLocation[0]][validLocation[1]].table;
        for (i = _i = 0; 0 <= subBoard ? _i < subBoard : _i > subBoard; i = 0 <= subBoard ? ++_i : --_i) {
          if (this.twoCells([subBoard[i][0].val, subBoard[i][1].val, subBoard[i][2].val])) {
            return true;
          }
          if (this.twoCells([subBoard[0][i].val, subBoard[1][i].val, subBoard[2][i].val])) {
            return true;
          }
        }
        if (this.twoCells([subBoard[0][0].val, subBoard[1][1].val, subBoard[2][2].val])) {
          return true;
        }
        if (this.twoCells([subBoard[0][2].val, subBoard[1][1].val, subBoard[2][0].val])) {
          return true;
        }
        return false;
      };

      OnePlayerModel.prototype.twoCells = function(row) {
        var _ref, _ref1, _ref2;
        return (row[0] === (_ref = row[1]) && _ref !== 0) || (row[0] === (_ref1 = row[2]) && _ref1 !== 0) || (row[1] === (_ref2 = row[2]) && _ref2 !== 0);
      };

      OnePlayerModel.prototype.boardScore = function(subBoard) {
        var currentBoard, score;
        score = 0;
        if (subBoard != null) {
          currentBoard = subBoard;
        } else {
          currentBoard = this.board;
        }
        if (currentBoard.val === 0) {
          return this.columnScore(currentBoard.table) + this.rowScore(currentBoard.table) + this.crossScore(currentBoard.table);
        }
        return currentBoard.val * (subBoard != null ? 100 : 10000);
      };

      OnePlayerModel.prototype.rowScore = function(currentBoard) {
        var abs, cell, row, score, subSum, sum, val, _i, _j, _k, _len, _len1, _len2;
        score = 0;
        for (_i = 0, _len = currentBoard.length; _i < _len; _i++) {
          row = currentBoard[_i];
          if (row[0].table != null) {
            sum = abs = subSum = 0;
            for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
              cell = row[_j];
              val = this.boardScore(cell);
              if (Math.abs(val) === 100) {
                abs += Math.abs(val);
                sum += val;
              } else {
                subSum += val;
              }
            }
            if (abs === Math.abs(sum)) {
              if (abs === 200) {
                score += (sum + subSum) * 10;
              } else {
                score += sum + subSum;
              }
            } else {
              score += subSum;
            }
          } else {
            sum = abs = 0;
            for (_k = 0, _len2 = row.length; _k < _len2; _k++) {
              cell = row[_k];
              val = cell.val;
              abs += Math.abs(val);
              sum += val;
            }
            if (abs === Math.abs(sum)) {
              if (abs === 2) {
                score += sum * 10;
              } else {
                score += sum;
              }
            }
          }
        }
        return score;
      };

      OnePlayerModel.prototype.columnScore = function(currentBoard) {
        var abs, i, j, score, subSum, sum, val, _i, _j, _k, _ref, _ref1, _ref2;
        score = 0;
        for (i = _i = 0, _ref = currentBoard.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (currentBoard[0][0].table != null) {
            sum = abs = subSum = 0;
            for (j = _j = 0, _ref1 = currentBoard[i].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              val = this.boardScore(currentBoard[j][i]);
              if (Math.abs(val) === 100) {
                abs += Math.abs(val);
                sum += val;
              } else {
                subSum += val;
              }
            }
            if (abs === Math.abs(sum)) {
              if (abs === 200) {
                score += (sum + subSum) * 10;
              } else {
                score += sum + subSum;
              }
            } else {
              score += subSum;
            }
          } else {
            sum = abs = 0;
            for (j = _k = 0, _ref2 = currentBoard[i].length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
              val = currentBoard[j][i].val;
              abs += Math.abs(val);
              sum += val;
            }
            if (abs === Math.abs(sum)) {
              if (abs === 2) {
                score += sum * 10;
              } else {
                score += sum;
              }
            }
          }
        }
        return score;
      };

      OnePlayerModel.prototype.crossScore = function(currentBoard) {
        var abs, i, score, subSum, sum, val, _i, _ref;
        abs = sum = score = subSum = 0;
        for (i = _i = 0, _ref = currentBoard.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (currentBoard[0][0].table != null) {
            val = this.boardScore(currentBoard[i][i]);
            if (Math.abs(val) === 100) {
              abs += Math.abs(val);
              sum += val;
            } else {
              subSum += val;
            }
            val = this.boardScore(currentBoard[i][2 - i]);
            if (Math.abs(val) === 100) {
              abs += Math.abs(val);
              sum += val;
            } else {
              subSum += val;
            }
            if (abs === Math.abs(sum)) {
              if (abs === 200) {
                score += (sum + subSum) * 10;
              } else {
                score += sum + subSum;
              }
            } else {
              score += subSum;
            }
          } else {
            val = currentBoard[i][i].val;
            abs += Math.abs(val);
            sum += val;
            val = currentBoard[i][2 - i].val;
            abs += Math.abs(val);
            sum += val;
            if (abs === Math.abs(sum)) {
              if (abs === 2) {
                score += sum * 10;
              } else {
                score += sum;
              }
            }
          }
        }
        return score;
      };

      return OnePlayerModel;

    })(GameApp.GameModel);
  });

}).call(this);
